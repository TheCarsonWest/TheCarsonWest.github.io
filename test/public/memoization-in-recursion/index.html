
<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Memoization in Recursion | Nerd-Emoji Web</title>
    <link rel="stylesheet" href="https://thecarsonwest.github.io/css/style.css" />
    <link rel="stylesheet" href="https://thecarsonwest.github.io/css/fonts.css" />
    <link rel="icon" type="image/x-icon" href="https://thecarsonwest.github.io/nerd-emoji.ico">

        
    <script type="text/javascript"
            src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
    
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'] ],
          processEscapes: true
        }
      });
    </script>
  </head>

  <body>
    <nav>
    <ul class="menu">
      
    </ul>
    <hr/>
    </nav>
<div class="article-meta">
<h1><span class="title">Memoization in Recursion</span></h1>
<h2 class="author">Carson West</h2>

</div>

<main>
<h2 id="memoization-in-recursionmemoization-in-recursion">[Memoization in [<a href="./../memoization-in-%5B%5Brecursion/">Recursion</a></h2>
<h3 id="what-is-memoization">What is Memoization?</h3>
<p>Memoization is a technique used in recursion to optimize performance by storing the results of function calls in a cache. This prevents the function from recomputing the same values multiple times, resulting in significantly faster execution times.</p>
<h3 id="how-to-use-memoization">How to Use Memoization</h3>
<p>Memoization can be implemented using a decorator function, which wraps the original function and checks the cache for existing results before executing the function again.</p>
<p>The decorator typically has a parameter <code>cache</code> to store the cached results. If the result for the current function call is not present in the cache, the function is executed and the result is added to the cache before being returned.</p>
<h3 id="code-examples">Code Examples</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># memoization decorator</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">memoize</span>(cache<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>):
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> cache <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span> cache <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">wrapper</span>(func):
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">memoized_func</span>(<span style="color:#f92672">*</span>args):
</span></span><span style="display:flex;"><span> key <span style="color:#f92672">=</span> args
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> key <span style="color:#f92672">not</span> <span style="color:#f92672">in</span> cache:
</span></span><span style="display:flex;"><span> cache[key] <span style="color:#f92672">=</span> func(<span style="color:#f92672">*</span>args)
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">return</span> cache[key]
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">return</span> memoized_func
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">return</span> wrapper
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># example function to calculate the Fibonacci number</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@memoize</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">fibonacci</span>(n):
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> n <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span>:
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">return</span> n
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">return</span> fibonacci(n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">+</span> fibonacci(n<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>)
</span></span></code></pre></div><h3 id="related-python-concepts">Related Python Concepts</h3>
<ul>
<li><a href="./../recursion/">Recursion</a>: Memoization is directly related to recursion, as it optimizes recursive function calls.</li>
<li><a href="./../caches/">Caches</a>: Memoization involves the use of a cache to store the results of function calls.</li>
<li><a href="./../decorators/">Decorators</a>: Memoization is implemented using a decorator function.</li>
<li><a href="./../dynamic-programming/">Dynamic Programming</a>: Memoization is a key technique in dynamic programming, which optimizes recursive solutions by storing intermediate results.</li>
<li><a href="./../optimizations/">Optimizations</a>: Memoization is a method of optimizing the performance of recursive functions.</li>
</ul>

</main>

  <footer>
  
  
  </footer>
  </body>
</html>

