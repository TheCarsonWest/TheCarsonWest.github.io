
<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Clean Code Summary | Nerd-Emoji Web</title>
    <style>
      body {
          font-family: 'Open Sans'
      }
      </style>
    <link rel="stylesheet" href="https://thecarsonwest.github.io/css/style.css" />
    <link rel="icon" type="image/x-icon" href="https://thecarsonwest.github.io/nerd-emoji.ico">
    <link href='https://fonts.googleapis.com/css?family=Open Sans' rel='stylesheet'>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS_CHTML"></script>

<script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$']]
    },
    svg: {
      fontCache: 'global'
    }
  };
  </script>
    
  </head>

  <body>

    <nav>
    <ul class="menu">
      
    </ul>
    <hr/>
    </nav>
<div class="article-meta">
<h1><span class="title">Clean Code Summary</span></h1>
<h2 class="author">Carson West</h2>

</div>

<main>
<h1 id="useful-websites-and-articles">[[Useful Websites and Articles]]</h1>
<h1 id="clean-code-summary">[[Clean Code Summary]]</h1>
<p><strong>Key Principles:</strong></p>
<ul>
<li>
<p><strong>Meaningful Names:</strong>  Choose names that clearly reveal intent. Avoid abbreviations or acronyms unless widely understood within the context.  Example: <code>userName</code> instead of <code>un</code>.</p>
</li>
<li>
<p><strong>Functions:</strong></p>
<ul>
<li><strong>Small:</strong> Keep functions short and focused on a single task.  A function should ideally fit on a single screen.</li>
<li><strong>One Level of Abstraction:</strong> Functions should operate at the same level of abstraction.  Mixing levels leads to confusion.</li>
<li><strong>Do One Thing:</strong> Functions should do exactly one thing. If a function does more than one thing, it&rsquo;s likely to need refactoring.</li>
</ul>
</li>
<li>
<p><strong>Comments:</strong></p>
<ul>
<li><strong>Explain why, not what:</strong> Comments should explain the reasoning behind the code, not simply restate what the code already says.</li>
<li><strong>Keep comments up-to-date:</strong> Outdated comments are worse than no comments.</li>
</ul>
</li>
<li>
<p><strong>Formatting:</strong></p>
<ul>
<li><strong>Consistency:</strong>  Maintain consistent indentation, spacing, and line breaks throughout the codebase.  This improves readability.</li>
<li><strong>Vertical Formatting:</strong> Separate logical sections of code with blank lines.</li>
</ul>
</li>
<li>
<p><strong>[[Error Handling]]:</strong></p>
<ul>
<li><strong>Use exceptions appropriately:</strong> Avoid excessive exception handling that clutters the code.  Use exceptions for genuine exceptional conditions.</li>
<li><strong>Handle errors gracefully:</strong> Provide informative error messages to the user and log errors appropriately for debugging.</li>
</ul>
</li>
<li>
<p><strong>Classes:</strong></p>
<ul>
<li><strong>Single Responsibility Principle (SRP):</strong> A class should have only one reason to change.</li>
<li><strong>Open/Closed Principle (OCP):</strong> Classes should be open for extension, but closed for modification.</li>
<li><strong>Liskov Substitution Principle (LSP):</strong> Subtypes should be substitutable for their base types without altering the correctness of the program.</li>
<li><strong>Interface Segregation Principle (ISP):</strong> Clients should not be forced to depend upon interfaces they don&rsquo;t use.</li>
<li><strong>Dependency Inversion Principle (DIP):</strong> High-level modules should not depend on low-level modules. Both should depend on abstractions. Abstractions should not depend on details. Details should depend on abstractions.</li>
</ul>
</li>
<li>
<p><strong>SOLID Principles:</strong> [[SOLID Principles Explained]]</p>
</li>
<li>
<p><strong>Testing:</strong></p>
<ul>
<li><strong>Write tests first (Test-Driven Development - TDD):</strong>  Define the expected behavior of your code before writing the code itself.</li>
<li><strong>Keep tests concise and readable:</strong>  Tests should be easy to understand and maintain.</li>
<li><strong>High test coverage:</strong> Aim for a high level of test coverage to ensure code quality.</li>
</ul>
</li>
<li>
<p><strong>Refactoring:</strong></p>
<ul>
<li><strong>Iterative process:</strong> Refactoring is an iterative process of improving code design without changing its functionality.</li>
<li><strong>Small steps:</strong> Make small, incremental changes during refactoring to reduce the risk of introducing errors.</li>
<li><strong>Use automated tests:</strong>  Automated tests help ensure that your refactoring doesn&rsquo;t break existing functionality.</li>
</ul>
</li>
<li>
<p><strong>Code Smells:</strong> [[Code Smells Catalog]]</p>
</li>
<li>
<p><strong>Design Patterns:</strong> [[Common Design Patterns]]</p>
</li>
<li>
<p><strong>Estimating Code Complexity:</strong>  $  cyclomatic \ complexity = E - N + 2P  $  where  $ E $  is the number of edges,  $ N $  is the number of nodes, and  $ P $  is the number of connected components.  This equation helps assess complexity; higher values indicate more complex code.  A low cyclomatic complexity generally means a simpler, more maintainable function.</p>
</li>
<li>
<p><strong>General Tips:</strong></p>
<ul>
<li>Keep it simple.</li>
<li>Strive for readability.</li>
<li>Review your own and others&rsquo; code regularly.</li>
<li>Use a linter.</li>
</ul>
</li>
</ul>
<p>This is a summary; each point warrants further investigation.  I will create detailed notes on each of the linked topics above.</p>

</main>

  <footer>
  
  
  </footer>
  </body>
</html>

