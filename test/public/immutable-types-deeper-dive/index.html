
<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Immutable Types Deeper Dive | Nerd-Emoji Web</title>
    <style>
      body {
          font-family: 'Open Sans'
      }
      </style>
    <link rel="stylesheet" href="https://thecarsonwest.github.io/css/style.css" />
    <link rel="icon" type="image/x-icon" href="https://thecarsonwest.github.io/nerd-emoji.ico">
    <link href='https://fonts.googleapis.com/css?family=Open Sans' rel='stylesheet'>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS_CHTML"></script>

<script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$']]
    },
    svg: {
      fontCache: 'global'
    }
  };
  </script>
    
  </head>

  <body>

    <nav>
    <ul class="menu">
      
    </ul>
    <hr/>
    </nav>
<div class="article-meta">
<h1><span class="title">Immutable Types Deeper Dive</span></h1>
<h2 class="author">Carson West</h2>

</div>

<main>
<h1 id="mutable-vs-immutable-types">[[Mutable vs Immutable Types]]</h1>
<h1 id="immutable-types-deeper-dive">[[Immutable Types]]: Deeper Dive</h1>
<p>This note expands on the concept of immutability in Python.  Key [[Immutable Types]] include:</p>
<ul>
<li><code>int</code> (integers)</li>
<li><code>float</code> (floating-point numbers)**</li>
<li><code>bool</code> (booleans)</li>
<li><code>str</code> (strings)</li>
<li><code>tuple</code> ([[Tuples]])</li>
<li><code>frozenset</code> ([[Frozen Sets]])</li>
</ul>
<p><strong>What does immutability mean?</strong></p>
<p>It means that once an immutable object is created, its value cannot be changed.  Any operation that appears to modify an immutable object actually creates a new object with the modified value.</p>
<p><strong>Example (Strings):</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>my_string <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hello&#34;</span>
</span></span><span style="display:flex;"><span>my_string <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34; world&#34;</span>  <span style="color:#75715e"># This doesn&#39;t modify my_string in place.</span>
</span></span><span style="display:flex;"><span>print(id(my_string)) <span style="color:#75715e"># print memory location of original string</span>
</span></span><span style="display:flex;"><span>my_string2 <span style="color:#f92672">=</span> my_string <span style="color:#75715e"># assigning the same value to another variable.</span>
</span></span><span style="display:flex;"><span>print(id(my_string2)) <span style="color:#75715e"># shows that it is the same memory location as my_string.</span>
</span></span><span style="display:flex;"><span>print(my_string)  <span style="color:#75715e"># Output: hello world</span>
</span></span><span style="display:flex;"><span>print(id(my_string)) <span style="color:#75715e"># shows a new memory location, because we created a new string.</span>
</span></span></code></pre></div><p><strong>Example ([[Tuples]]):</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>my_tuple <span style="color:#f92672">=</span> ([[<span style="color:#ae81ff">1</span>]], [[<span style="color:#ae81ff">2</span>]], [[<span style="color:#ae81ff">3</span>]])
</span></span><span style="display:flex;"><span><span style="color:#75715e"># my_tuple[0] = [[4]]  # This will raise a TypeError: &#39;tuple&#39; object does not support item assignment.</span>
</span></span><span style="display:flex;"><span>new_tuple <span style="color:#f92672">=</span> my_tuple <span style="color:#f92672">+</span> ([[<span style="color:#ae81ff">4</span>]],) <span style="color:#75715e"># creates a new tuple with value [[4]] concatenated.</span>
</span></span><span style="display:flex;"><span>print(new_tuple) <span style="color:#75715e"># Output: ([[1]], [[2]], [[3]], [[4]])</span>
</span></span></code></pre></div><p><strong>Implications of Immutability:</strong></p>
<ul>
<li><strong>Thread safety:</strong> Immutable objects can be safely shared between multiple threads without the risk of data corruption. [[Thread Safety]]</li>
<li><strong>Data integrity:</strong>  You can be confident that the value of an immutable object will not change unexpectedly.</li>
<li><strong>Hashing:</strong>  Immutable objects can be used as keys in [[Dictionaries]] because their hash value remains constant. [[Hashing in Python]]</li>
<li><strong>Performance:</strong> While creating new objects might seem inefficient, Python&rsquo;s memory management often optimizes this.  However, frequent modifications to large immutable objects can impact performance.</li>
</ul>
<p><strong>Contrast with Mutable Types:</strong></p>
<p>Mutable types, like [[Lists]] and [[Dictionaries]], can be modified in place.  This allows for more flexibility but also introduces potential risks related to concurrency and unintended side effects. [[Mutable Types in Python]]</p>
<p><strong>Further Exploration:</strong></p>
<ul>
<li>Deep vs. shallow copying with immutable and mutable objects. [[Deep vs. Shallow Copy]]</li>
<li>Understanding how Python&rsquo;s garbage collector handles immutable objects. [[Python Garbage Collection]]</li>
</ul>

</main>

  <footer>
  
  
  </footer>
  </body>
</html>

