
<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>C3 Linearization Algorithm | Nerd-Emoji Web</title>
    <style>
      body {
          font-family: 'Open Sans'
      }
      </style>
    <link rel="stylesheet" href="https://thecarsonwest.github.io/css/style.css" />
    <link rel="icon" type="image/x-icon" href="https://thecarsonwest.github.io/nerd-emoji.ico">
    <link href='https://fonts.googleapis.com/css?family=Open Sans' rel='stylesheet'>

    <script id="MathJax-script" async
    src="./../../../tex-mml-chtml.js">
</script>
<script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$']]
    },
    svg: {
      fontCache: 'global'
    }
  };
  </script>
    
  </head>

  <body>

    <nav>
    <ul class="menu">
      
    </ul>
    <hr/>
    </nav>
<div class="article-meta">
<h1><span class="title">C3 Linearization Algorithm</span></h1>
<h2 class="author">Carson West</h2>

</div>

<main>
<h1 id="method-resolution-order-mromethod-resolution-order-mro"><a href="./../method-resolution-order-(mro)/">Method Resolution Order (MRO)</a></h1>
<h1 id="c3-linearization-algorithm">C3 Linearization Algorithm</h1>
<p>This note covers the C3 linearization algorithm used in Python&rsquo;s method resolution order (MRO) for resolving conflicts in multiple inheritance.</p>
<p>The core goal is to maintain a consistent and predictable order for attribute lookup in classes with multiple inheritance, avoiding ambiguities and ensuring that the intended superclass methods are called.  The algorithm is designed to be:</p>
<ul>
<li><strong>Consistent:</strong>  Always produces the same MRO for a given class hierarchy.</li>
<li><strong>Intuitive:</strong> The resulting MRO generally reflects a programmer&rsquo;s intuitive expectations (though edge cases can exist).</li>
<li><strong>Correct:</strong> Prevents conflicts and ensures that the desired superclass methods are called in the appropriate order.</li>
</ul>
<p>The algorithm itself is complex, but can be understood through its principles:</p>
<ol>
<li>
<p><strong>Depth-First Search:</strong>  It starts with the class itself, and then traverses the inheritance tree in a depth-first manner.</p>
</li>
<li>
<p><strong>Linearization:</strong> It aims to create a linear order of superclasses, ensuring that all parents are visited in a consistent manner.</p>
</li>
<li>
<p><strong>Merging:</strong> When encountering multiple inheritance, the algorithm carefully merges the MROs of the parent classes to avoid conflicts.  It uses a sophisticated approach to ensure that the linearization is consistent across different inheritance paths.</p>
</li>
<li>
<p><strong>C3 Algorithm&rsquo;s &ldquo;Monotonicity&rdquo; Property:</strong> A key aspect of C3 is its guarantee of monotonicity. This property ensures that, if a class B is listed before C in the linearization of A, B will always appear before C in the linearization of any subclass of A.</p>
</li>
</ol>
<p>Example illustrating the C3 algorithm:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pass</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span>(A):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pass</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">C</span>(A):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pass</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">D</span>(B, C):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pass</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(D<span style="color:#f92672">.</span>__mro__)  <span style="color:#75715e"># Output: (&lt;class &#39;__main__.D&#39;&gt;, &lt;class &#39;__main__.B&#39;&gt;, &lt;class &#39;__main__.C&#39;&gt;, &lt;class &#39;__main__.A&#39;&gt;, &lt;class &#39;object&#39;&gt;)</span>
</span></span></code></pre></div><p>In this case, the C3 algorithm produces the MRO <code>&lt;D, B, C, A, object&gt;</code>.</p>
<p><a href="./../python-mro/">Python MRO</a>  (<a href="./../multiple-inheritance-in-python/">Multiple Inheritance in Python</a>) <a href="./../depth-first-search/">Depth-First Search</a></p>
<p>The C3 algorithm is crucial for understanding Python&rsquo;s sophisticated approach to multiple inheritance. While the algorithm&rsquo;s implementation details are intricate, the core principles of depth-first traversal and the careful merging of MROs ensure consistent and predictable behavior.  Understanding the intricacies allows for effective use and avoidance of unexpected behaviors in complex inheritance scenarios.</p>

</main>

  <footer>
  
  
  </footer>
  </body>
</html>

